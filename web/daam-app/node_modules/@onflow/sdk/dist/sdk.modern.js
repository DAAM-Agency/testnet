import{invariant as e}from"@onflow/util-invariant";import{spawn as t,SUBSCRIBE as n,UNSUBSCRIBE as a,send as r,subscriber as o}from"@onflow/util-actor";import{Transaction as s,SendTransactionRequest as c,AccessAPI as i,GetTransactionRequest as u,ExecuteScriptAtBlockIDRequest as l,ExecuteScriptAtBlockHeightRequest as d,ExecuteScriptAtLatestBlockRequest as g,GetAccountAtBlockHeightRequest as p,GetAccountAtLatestBlockRequest as f,GetEventsForHeightRangeRequest as m,GetEventsForBlockIDsRequest as h,GetBlockByIDRequest as y,GetBlockByHeightRequest as k,GetLatestBlockRequest as b,GetBlockHeaderByIDRequest as I,GetBlockHeaderByHeightRequest as w,GetLatestBlockHeaderRequest as S,GetCollectionByIDRequest as B,PingRequest as v}from"@onflow/protobuf";import{sansPrefix as E,withPrefix as A}from"@onflow/util-address";import{grpc as T}from"@improbable-eng/grpc-web";import{NodeHttpTransport as N}from"@improbable-eng/grpc-web-node-http-transport";import{encode as x}from"@onflow/rlp";import{template as L}from"@onflow/util-template";export{template as cadence,template as cdc}from"@onflow/util-template";function O(){return(O=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const _='{\n  "tag":"UNKNOWN",\n  "assigns":{},\n  "status":"OK",\n  "reason":null,\n  "accounts":{},\n  "params":{},\n  "arguments":{},\n  "message": {\n    "cadence":null,\n    "refBlock":null,\n    "computeLimit":null,\n    "proposer":null,\n    "payer":null,\n    "authorizations":[],\n    "params":[],\n    "arguments":[]\n  },\n  "proposer":null,\n  "authorizations":[],\n  "payer":null,\n  "events": {\n    "eventType":null,\n    "start":null,\n    "end":null,\n    "blockIds":[]\n  },\n  "transaction": {\n    "id":null\n  },\n  "block": {\n    "id":null,\n    "height":null,\n    "isSealed":null\n  },\n  "account": {\n    "addr":null\n  },\n  "collection": {\n    "id":null\n  }\n}',G=new Set(Object.keys(JSON.parse(_))),C=()=>JSON.parse(_),U="abcdefghijklmnopqrstuvwxyz0123456789".split(""),D=()=>U[~~(Math.random()*U.length)],K=()=>Array.from({length:10},D).join(""),R=e=>null==e,P=e=>(e.status="OK",e),F=(e,t)=>(e.status="BAD",e.reason=t,e),H=e=>t=>(t.tag=e,P(t)),j=(t,n={})=>a=>{e("function"==typeof t||"object"==typeof t,"prepAccount must be passed an authorization function or an account object"),e(null!=n.role,"Account must have a role");const r=JSON.parse('{\n  "kind":"ACCOUNT",\n  "tempId":null,\n  "addr":null,\n  "keyId":null,\n  "sequenceNum":null,\n  "signature":null,\n  "signingFunction":null,\n  "resolve":null,\n  "role": {\n    "proposer":false,\n    "authorizer":false,\n    "payer":false,\n    "param":false\n  }\n}'),o=n.role,s=K();return a.accounts[s]=O({},r,{tempId:s},t="function"==typeof t?{resolve:t}:t,{role:O({},r.role,"object"==typeof t.role?t.role:{},{[o]:!0})}),"authorizer"===o?a.authorizations.push(s):a[o]=s,a},z=e=>t=>{let n=K();return t.message.arguments.push(n),t.arguments[n]=JSON.parse('{\n  "kind":"ARGUMENT",\n  "tempId":null,\n  "value":null,\n  "asArgument":null,\n  "xform":null,\n  "resolve": null\n}'),t.arguments[n].tempId=n,t.arguments[n].value=e.value,t.arguments[n].asArgument=e.asArgument,t.arguments[n].xform=e.xform,t.arguments[n].resolve=e.resolve,P(t)},q=H("SCRIPT"),J=H("TRANSACTION"),$=H("GET_TRANSACTION_STATUS"),M=H("GET_TRANSACTION"),W=H("GET_ACCOUNT"),Y=H("GET_EVENTS"),V=H("GET_LATEST_BLOCK"),X=H("GET_BLOCK_BY_ID"),Q=H("GET_BLOCK_BY_HEIGHT"),Z=H("PING"),ee=H("GET_BLOCK"),te=H("GET_BLOCK_HEADER"),ne=H("GET_COLLECTION"),ae=e=>t=>t.tag===e,re=ae("UNKNOWN"),oe=ae("SCRIPT"),se=ae("TRANSACTION"),ce=ae("GET_TRANSACTION_STATUS"),ie=ae("GET_TRANSACTION"),ue=ae("GET_ACCOUNT"),le=ae("GET_EVENTS"),de=ae("GET_LATEST_BLOCK"),ge=ae("GET_BLOCK_BY_ID"),pe=ae("GET_BLOCK_BY_HEIGHT"),fe=ae("PING"),me=ae("GET_BLOCK"),he=ae("GET_BLOCK_HEADER"),ye=ae("GET_COLLECTION"),ke=e=>"OK"===e.status,be=e=>"BAD"===e.status,Ie=e=>e.reason,we=async(e,t=[])=>{try{if(e=(e=>{for(let t of Object.keys(e))if(!G.has(t))throw new Error(`"${t}" is an invalid root level Interaction property.`);return e})(await e),be(e))throw new Error("Interaction Error: "+e.reason);if(!t.length)return e;const[n,...a]=t,r=await n;if("function"==typeof r)return we(r(e),a);if(R(r)||!r)return we(e,a);if((e=>{if(null===(t=e)||"object"!=typeof t||R(e)||(e=>"number"==typeof e)(e))return!1;var t;for(let t of G)if(!e.hasOwnProperty(t))return!1;return!0})(r))return we(r,a);throw new Error("Invalid Interaction Composition")}catch(e){throw e}},Se=(...e)=>{const[t,n]=e;return Array.isArray(t)&&null==n?e=>Se(e,t):we(t,n)},Be=e=>e,ve=(e,t,n)=>null==e.assigns[t]?n:e.assigns[t],Ee=(e,t)=>n=>(n.assigns[e]=t,P(n)),Ae=(e,t=Be)=>n=>(n.assigns[e]=t(n.assigns[e],n),P(n)),Te=e=>t=>(delete t.assigns[e],P(t));function Ne(e=[]){return Se(C(),e)}const xe="config",Le="PUT_CONFIG",Oe="GET_CONFIG",_e="CONFIG/UPDATED",Ge=e=>e,Ce={[Le]:(e,t,{key:n,value:a})=>{if(null==n)throw new Error("Missing 'key' for config/put.");e.put(n,a),e.broadcast(_e,e.all())},[Oe]:(e,t,{key:n,fallback:a})=>{if(null==n)throw new Error("Missing 'key' for config/get");t.reply(e.get(n,a))},UPDATE_CONFIG:(e,t,{key:n,fn:a})=>{if(null==n)throw new Error("Missing 'key' for config/update");e.update(n,a||Ge),e.broadcast(_e,e.all())},DELETE_CONFIG:(e,t,{key:n})=>{if(null==n)throw new Error("Missing 'key' for config/delete");e.delete(n),e.broadcast(_e,e.all())},WHERE_CONFIG:(e,t,{pattern:n})=>{if(null==n)throw new Error("Missing 'pattern' for config/where");t.reply(e.where(n))},[n]:(e,t)=>{e.subscribe(t.from),e.send(t.from,_e,e.all())},[a]:(e,t)=>{e.unsubscribe(t.from)}};function Ue(e,t){return r(xe,Le,{key:e,value:t}),He()}function De(e,t){return r(xe,Oe,{key:e,fallback:t},{expectReply:!0,timeout:10})}function Ke(e,t=Ge){return r(xe,"UPDATE_CONFIG",{key:e,fn:t}),He()}function Re(e){return r(xe,"DELETE_CONFIG",{key:e}),He()}function Pe(e){return r(xe,"WHERE_CONFIG",{pattern:e},{expectReply:!0,timeout:10})}function Fe(e){return o(xe,()=>t(Ce,xe),e)}function He(e){return null!=e&&"object"==typeof e&&Object.keys(e).map(t=>Ue(t,e[t])),{put:Ue,get:De,update:Ke,delete:Re,where:Pe,subscribe:Fe}}t(Ce,xe);const je=()=>JSON.parse('{\n    "tag":null,\n    "transaction":null,\n    "transactionStatus":null,\n    "transactionId":null,\n    "encodedData":null,\n    "events":null,\n    "account":null,\n    "block":null,\n    "blockHeader":null,\n    "latestBlock":null,\n    "collection":null\n}');async function ze(e,t,n){const a=await He().get("grpc.metadata",{});return new Promise((r,o)=>{T.unary(t,{request:n,host:e,metadata:new T.Metadata(a),onEnd:({status:e,statusMessage:t,message:n})=>{e===T.Code.OK?r(n):o(new Error(t))}})})}T.setDefaultTransport(N());const qe=e=>Buffer.from(e,"hex"),Je=e=>Buffer.from(e.padStart(16,0),"hex"),$e=e=>Buffer.from(e).toString("hex"),Me=e=>Buffer.from(JSON.stringify(e),"utf8"),We=e=>Buffer.from(e).toString("hex"),Ye=e=>Buffer.from(e).toString("hex"),Ve=e=>Buffer.from(e).toString("hex"),Xe=e=>Buffer.from(e).toString("hex"),Qe=e=>Buffer.from(e).toString("hex"),Ze=e=>Buffer.from(e).toString("hex"),et=e=>Buffer.from(e).toString("hex"),tt=e=>Buffer.from(e).toString("hex"),nt=async(e,t={})=>{switch(t.node=t.node||await He().get("accessNode.api"),e=await e,!0){case se(e):return t.sendTransaction?t.sendTransaction(e,t):async function(e,t={}){const n=t.unary||ze;e=await e;const a=new s;a.setScript((e=>Buffer.from(e,"utf8"))(e.message.cadence)),a.setGasLimit(e.message.computeLimit),a.setReferenceBlockId(e.message.refBlock?qe(e.message.refBlock):null),a.setPayer(Je(E(e.accounts[e.payer].addr))),e.message.arguments.forEach(t=>a.addArguments((e=>Buffer.from(JSON.stringify(e),"utf8"))(e.arguments[t].asArgument))),e.authorizations.map(t=>e.accounts[t].addr).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[]).forEach(e=>a.addAuthorizers(Je(E(e))));const r=new s.ProposalKey;r.setAddress(Je(E(e.accounts[e.proposer].addr))),r.setKeyId(e.accounts[e.proposer].keyId),r.setSequenceNumber(e.accounts[e.proposer].sequenceNum),a.setProposalKey(r);for(let t of Object.values(e.accounts))try{if(!t.role.payer&&null!=t.signature){const e=new s.Signature;e.setAddress(Je(E(t.addr))),e.setKeyId(t.keyId),e.setSignature(qe(t.signature)),a.addPayloadSignatures(e)}}catch(n){throw console.error("Trouble applying payload signature",{acct:t,ix:e}),n}for(let t of Object.values(e.accounts))try{if(t.role.payer&&null!=t.signature){const e=new s.Signature;e.setAddress(Je(E(t.addr))),e.setKeyId(t.keyId),e.setSignature(qe(t.signature)),a.addEnvelopeSignatures(e)}}catch(n){throw console.error("Trouble applying envelope signature",{acct:t,ix:e}),n}const o=new c;o.setTransaction(a);var u=Date.now();const l=await n(t.node,i.SendTransaction,o);var d=Date.now();let g=je();var p;return g.tag=e.tag,g.transactionId=(p=l.getId_asU8(),Buffer.from(p).toString("hex")),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("FLOW::TX",{detail:{txId:g.transactionId,delta:d-u}})),g}(e,t);case ce(e):return t.sendGetTransactionStatus?t.sendGetTransactionStatus(e,t):async function(e,t={}){const n=t.unary||ze;e=await e;const a=new u;a.setId(Buffer.from(e.transaction.id,"hex"));const r=await n(t.node,i.GetTransactionResult,a);let o=r.getEventsList(),s=je();return s.tag=e.tag,s.transactionStatus={status:r.getStatus(),statusCode:r.getStatusCode(),errorMessage:r.getErrorMessage(),events:o.map(e=>{return{type:e.getType(),transactionId:(t=e.getTransactionId_asU8(),Buffer.from(t).toString("hex")),transactionIndex:e.getTransactionIndex(),eventIndex:e.getEventIndex(),payload:JSON.parse(Buffer.from(e.getPayload_asU8()).toString("utf8"))};var t})},s}(e,t);case ie(e):return t.sendGetTransaction?t.sendGetTransaction(e,t):async function(e,t={}){const n=t.unary||ze;e=await e;const a=new u;a.setId(Buffer.from(e.transaction.id,"hex"));const r=await n(t.node,i.GetTransaction,a);let o=je();o.tag=e.tag;const s=e=>({address:$e(e.getAddress_asU8()),keyId:e.getKeyId(),signature:$e(e.getSignature_asU8())});let c=r.getTransaction();var l;return o.transaction={script:Buffer.from(c.getScript_asU8()).toString("utf8"),args:c.getArgumentsList().map(e=>JSON.parse(Buffer.from(e).toString("utf8"))),referenceBlockId:$e(c.getReferenceBlockId_asU8()),gasLimit:c.getGasLimit(),proposalKey:(l=c.getProposalKey(),{address:$e(l.getAddress_asU8()),keyId:l.getKeyId(),sequenceNumber:l.getSequenceNumber()}),payer:$e(c.getPayer_asU8()),authorizers:c.getAuthorizersList().map($e),payloadSignatures:c.getPayloadSignaturesList().map(s),envelopeSignatures:c.getEnvelopeSignaturesList().map(s)},o}(e,t);case oe(e):return t.sendExecuteScript?t.sendExecuteScript(e,t):async function(e,t={}){const n=t.unary||ze;let a,r;if((e=await e).block.id){a=new l,a.setBlockId(Buffer.from(e.block.id,"hex"));const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>a.addArguments(Me(e.arguments[t].asArgument))),a.setScript(o),r=await n(t.node,i.ExecuteScriptAtBlockID,a)}else if(e.block.height){a=new d,a.setBlockHeight(Number(e.block.height));const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>a.addArguments(Me(e.arguments[t].asArgument))),a.setScript(o),r=await n(t.node,i.ExecuteScriptAtBlockHeight,a)}else{a=new g;const o=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>a.addArguments(Me(e.arguments[t].asArgument))),a.setScript(o),r=await n(t.node,i.ExecuteScriptAtLatestBlock,a)}let o=je();return o.tag=e.tag,o.encodedData=JSON.parse(Buffer.from(r.getValue_asU8()).toString("utf8")),o}(e,t);case ue(e):return t.sendGetAccount?t.sendGetAccount(e,t):async function(e,t={}){const n=t.unary||ze,a=(e=await e).block.height?new p:new f;var r;e.block.height&&a.setBlockHeight(Number(e.block.height)),a.setAddress((r=E(e.account.addr),Buffer.from(r.padStart(16,0),"hex")));const o=await n(t.node,e.block.height?i.GetAccountAtBlockHeight:i.GetAccountAtLatestBlock,a);let s=je();s.tag=e.tag;const c=o.getAccount();let u;const l=(u=c.getContractsMap())?u.getEntryList().reduce((e,t)=>O({},e,{[t[0]]:Buffer.from(t[1]||new UInt8Array).toString("utf8")}),{}):{};return s.account={address:A(We(c.getAddress_asU8())),balance:c.getBalance(),code:Buffer.from(c.getCode_asU8()||new UInt8Array).toString("utf8"),contracts:l,keys:c.getKeysList().map(e=>({index:e.getIndex(),publicKey:We(e.getPublicKey_asU8()),signAlgo:e.getSignAlgo(),hashAlgo:e.getHashAlgo(),weight:e.getWeight(),sequenceNumber:e.getSequenceNumber(),revoked:e.getRevoked()}))},s}(e,t);case le(e):return t.sendGetEvents?t.sendGetEvents(e,t):async function(e,t={}){const n=t.unary||ze;let a;const r=(e=await e).events.start?new m:new h;r.setType(e.events.eventType),e.events.start?(r.setStartHeight(Number(e.events.start)),r.setEndHeight(Number(e.events.end)),a=await n(t.node,i.GetEventsForHeightRange,r)):(e.events.blockIds.forEach(e=>r.addBlockIds(Buffer.from(e,"hex"))),a=await n(t.node,i.GetEventsForBlockIDs,r));let o=je();o.tag=e.tag;const s=a.getResultsList();return o.events=s.reduce((e,t)=>{const n=Ye(t.getBlockId_asU8()),a=t.getBlockHeight(),r=t.getBlockTimestamp().toDate().toISOString();return t.getEventsList().forEach(t=>{e.push({blockId:n,blockHeight:a,blockTimestamp:r,type:t.getType(),transactionId:Ye(t.getTransactionId_asU8()),transactionIndex:t.getTransactionIndex(),eventIndex:t.getEventIndex(),payload:JSON.parse(Buffer.from(t.getPayload_asU8()).toString("utf8"))})}),e},[]),o}(e,t);case de(e):return t.sendGetLatestBlock?t.sendGetLatestBlock(e,t):async function(e,t={}){e=await e;const n=new b;e.latestBlock&&e.latestBlock.isSealed&&(n.setIsSealed(e.latestBlock.isSealed),console.error("\n          %c@onflow/send Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the interaction object is deprecated and will no longer be recognized in future releases of @onflow/send.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/send/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;")),e.block&&e.block.isSealed&&n.setIsSealed(e.block.isSealed);const a=(await ze(t.node,i.GetLatestBlock,n)).getBlock(),r=a.getCollectionGuaranteesList(),o=a.getBlockSealsList(),s=a.getSignaturesList(),c=je();return c.tag=e.tag,c.block={id:Qe(a.getId_asU8()),parentId:Qe(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:r.map(e=>({collectionId:Qe(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:o.map(e=>({blockId:Qe(e.getBlockId_asU8()),executionReceiptId:Qe(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:s},c}(e,t);case me(e):return t.sendGetBlock?t.sendGetBlock(e,t):async function(e,t={}){const n=t.unary||ze;let a,r;(e=await e).block.id?(a=new y,a.setId(Buffer.from(e.block.id,"hex")),r=await n(t.node,i.GetBlockByID,a)):e.block.height?(a=new k,a.setHeight(Number(e.block.height)),r=await n(t.node,i.GetBlockByHeight,a)):(a=new b,e.block&&e.block.isSealed&&a.setIsSealed(e.block.isSealed),r=await n(t.node,i.GetLatestBlock,a));const o=r.getBlock(),s=o.getCollectionGuaranteesList(),c=o.getBlockSealsList(),u=o.getSignaturesList().map(Ve),l=je();return l.tag=e.tag,l.block={id:Ve(o.getId_asU8()),parentId:Ve(o.getParentId_asU8()),height:o.getHeight(),timestamp:o.getTimestamp().toDate().toISOString(),collectionGuarantees:s.map(e=>({collectionId:Ve(e.getCollectionId_asU8()),signatures:e.getSignaturesList().map(Ve)})),blockSeals:c.map(e=>({blockId:Ve(e.getBlockId_asU8()),executionReceiptId:Ve(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList().map(Ve),resultApprovalSignatures:e.getResultApprovalSignaturesList().map(Ve)})),signatures:u},l}(e,t);case he(e):return t.sendGetBlockHeader?t.sendGetBlockHeader(e,t):async function(e,t={}){const n=t.unary||ze;let a,r;(e=await e).block.id?(a=new I,a.setId(Buffer.from(e.block.id,"hex")),r=await n(t.node,i.GetBlockHeaderByID,a)):e.block.height?(a=new w,a.setHeight(Number(e.block.height)),r=await n(t.node,i.GetBlockHeaderByHeight,a)):(a=new S,e.block&&e.block.isSealed&&a.setIsSealed(e.block.isSealed),r=await n(t.node,i.GetLatestBlockHeader,a));const o=r.getBlock(),s=je();return s.tag=e.tag,s.blockHeader={id:Xe(o.getId_asU8()),parentId:Xe(o.getParentId_asU8()),height:o.getHeight(),timestamp:o.getTimestamp().toDate().toISOString()},s}(e,t);case ge(e):return t.sendGetBlockById?t.sendGetBlockById(e,t):async function(e,t={}){e=await e;const n=new y;n.setId(Buffer.from(e.block.id,"hex"));const a=(await ze(t.node,i.GetBlockByID,n)).getBlock(),r=a.getCollectionGuaranteesList(),o=a.getBlockSealsList(),s=a.getSignaturesList(),c=je();return c.tag=e.tag,c.block={id:Ze(a.getId_asU8()),parentId:Ze(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:r.map(e=>({collectionId:Ze(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:o.map(e=>({blockId:Ze(e.getBlockId_asU8()),executionReceiptId:Ze(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:s},c}(e,t);case pe(e):return t.sendGetBlockByHeight?t.sendGetBlockByHeight(e,t):async function(e,t={}){e=await e;const n=new k;n.setHeight(Number(e.block.height));const a=(await ze(t.node,i.GetBlockByHeight,n)).getBlock(),r=a.getCollectionGuaranteesList(),o=a.getBlockSealsList(),s=a.getSignaturesList(),c=je();return c.tag=e.tag,c.block={id:et(a.getId_asU8()),parentId:et(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:r.map(e=>({collectionId:et(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:o.map(e=>({blockId:et(e.getBlockId_asU8()),executionReceiptId:et(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:s},c}(e,t);case ye(e):return t.sendGetCollection?t.sendGetCollection(e,t):async function(e,t={}){const n=t.unary||ze;e=await e;let a=new B;a.setId(Buffer.from(e.collection.id,"hex"));const r=(await n(t.node,i.GetCollectionByID,a)).getCollection(),o=je();return o.tag=e.tag,o.collection={id:tt(r.getId_asU8()),transactionIds:r.getTransactionIdsList().map(tt)},o}(e,t);case fe(e):return t.sendPing?t.sendPing(e,t):async function(e,t={}){const n=t.unary||ze;e=await e;const a=new v;await n(t.node,i.Ping,a);let r=je();return r.tag=e.tag,r}(e,t);default:return e}};function at(e=null){return Se([ee,t=>(t.block.isSealed=e,P(t))])}function rt(e){return Se([W,t=>(t.account.addr=E(e),P(t))])}const ot=async(e,t,n)=>{try{return Number(e)}catch(e){throw new Error("Decode Number Error : "+n.join("."))}},st=async e=>e,ct=async(e,t,n)=>{const a=await e.fields.reduce(async(e,a)=>((e=await e)[a.name]=await lt(a.value,t,[...n,a.name]),e),Promise.resolve({})),r=e.id&&ut(t,e.id);return r?await r(a):a},it={UInt:ot,Int:ot,UInt8:ot,Int8:ot,UInt16:ot,Int16:ot,UInt32:ot,Int32:ot,UInt64:ot,Int64:ot,UInt128:ot,Int128:ot,UInt256:ot,Int256:ot,Word8:ot,Word16:ot,Word32:ot,Word64:ot,UFix64:st,Fix64:st,String:st,Character:st,Bool:st,Address:st,Void:async()=>null,Optional:async(e,t,n)=>e?await lt(e,t,n):null,Reference:async e=>({address:e.address,type:e.type}),Array:async(e,t,n)=>await Promise.all(e.map(e=>new Promise(async a=>a(await lt(e,t,[...n,e.type]))))),Dictionary:async(e,t,n)=>await e.reduce(async(e,a)=>((e=await e)[await lt(a.key,t,[...n,a.key])]=await lt(a.value,t,[...n,a.key]),e),Promise.resolve({})),Event:ct,Resource:ct,Struct:ct},ut=(e,t)=>{const n=Object.keys(e).find(e=>/^\/.*\/$/.test(e)?new RegExp(e.substring(1,e.length-1)).test(t):e===t);return t&&n&&e[n]},lt=async(e,t,n)=>{let a=ut(t,e.type);if(!a)throw new Error(`Undefined Decoder Error: ${e.type}@${n.join(".")}`);return await a(e.value,t,n)},dt=async(e,t={},n=[])=>{let a=O({},it,t);return await lt(e,a,n)},gt=async(e,t={})=>{let n=O({},it,t);return e.encodedData?await dt(e.encodedData,n):e.transactionStatus?O({},e.transactionStatus,{events:await Promise.all(e.transactionStatus.events.map(async function(e){return{type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await dt(e.payload,n)}}))}):e.transaction?e.transaction:e.events?await Promise.all(e.events.map(async function(e){return{blockId:e.blockId,blockHeight:e.blockHeight,blockTimestamp:e.blockTimestamp,type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await dt(e.payload,n)}})):e.account?e.account:e.block?e.block:e.blockHeader?e.blockHeader:e.latestBlock?(console.error("\n          %c@onflow/decode Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;"),e.latestBlock):e.transactionId?e.transactionId:e.collection?e.collection:null};function pt(e){return async t=>se(t)?(t.message.refBlock||(t.message.refBlock=await async function(e){var t;return t=await Se(C(),[at()]),t=await nt(t,e),(t=await gt(t)).id}(e)),P(t)):P(t)}const ft=e=>"function"==typeof e,mt=e=>"string"==typeof e;async function ht(t){if(se(t)||oe(t)){var n=ve(t,"ix.cadence");e(ft(n)||mt(n),"Cadence needs to be a function or a string."),ft(n)&&(n=await n({})),e(mt(n),"Cadence needs to be a string at this point."),t.message.cadence=await He().where(/^0x/).then(e=>Object.entries(e).reduce((e,[t,n])=>e.replace(t,n),n))}return t}const yt=e=>"function"==typeof e;function kt(t){return e(null!=typeof t.xform,"No type specified for argument: "+t.value),yt(t.xform)?t.xform(t.value):yt(t.xform.asArgument)?t.xform.asArgument(t.value):void e(!1,"Invalid Argument",t)}async function bt(e){if(se(e)||oe(e))for(let[t,n]of Object.entries(e.arguments))e.arguments[t].asArgument=kt(n);return e}const It=e=>Et(xt(Lt(e))),wt=e=>Et(xt(Ot(e))),St=(e,t)=>Buffer.from(e.padStart(2*t,0),"hex"),Bt=(vt=Buffer.from("FLOW-V0.0-transaction").toString("hex"),Buffer.from(vt.padEnd(64,0),"hex")).toString("hex");var vt;const Et=e=>Bt+e,At=e=>St(e,8),Tt=e=>Buffer.from(JSON.stringify(e),"utf8"),Nt=e=>Buffer.from(e,"utf8"),xt=e=>x(e).toString("hex"),Lt=e=>{return Ct(e),[Nt(e.cadence),e.arguments.map(Tt),(t=e.refBlock,St(t,32)),e.computeLimit,At(e.proposalKey.address),e.proposalKey.keyId,e.proposalKey.sequenceNum,At(e.payer),e.authorizers.map(At)];var t},Ot=e=>(Ut(e),[Lt(e),_t(e)]),_t=e=>{const t=Gt(e);return e.payloadSigs.map(e=>({signerIndex:t.get(e.address),keyId:e.keyId,sig:e.sig})).sort((e,t)=>e.signerIndex>t.signerIndex?1:e.signerIndex<t.signerIndex?-1:e.keyId>t.keyId?1:e.keyId<t.keyId?-1:void 0).map(e=>{return[e.signerIndex,e.keyId,(t=e.sig,Buffer.from(t,"hex"))];var t})},Gt=e=>{const t=new Map;let n=0;const a=e=>{t.has(e)||(t.set(e,n),n++)};return a(e.proposalKey.address),a(e.payer),e.authorizers.forEach(a),t},Ct=e=>{Ft.forEach(t=>qt(e,t)),Ht.forEach(t=>qt(e.proposalKey,t,"proposalKey"))},Ut=e=>{jt.forEach(t=>qt(e,t)),e.payloadSigs.forEach((e,t)=>{zt.forEach(n=>qt(e,n,"payloadSigs",t))})},Dt=e=>"number"==typeof e,Kt=e=>"string"==typeof e,Rt=e=>null!==e&&"object"==typeof e,Pt=e=>Rt(e)&&e instanceof Array,Ft=[{name:"cadence",check:Kt},{name:"arguments",check:Pt},{name:"refBlock",check:Kt,defaultVal:"0"},{name:"computeLimit",check:Dt},{name:"proposalKey",check:Rt},{name:"payer",check:Kt},{name:"authorizers",check:Pt}],Ht=[{name:"address",check:Kt},{name:"keyId",check:Dt},{name:"sequenceNum",check:Dt}],jt=[{name:"payloadSigs",check:Pt}],zt=[{name:"address",check:Kt},{name:"keyId",check:Dt},{name:"sig",check:Kt}],qt=(e,t,n,a)=>{const{name:r,check:o,defaultVal:s}=t;if(null==e[r]&&null!=s&&(e[r]=s),null==e[r])throw $t(r,n,a);if(!o(e[r]))throw Mt(r,n,a)},Jt=(e,t,n)=>t?null==n?`${t}.${e}`:`${t}.${n}.${e}`:e,$t=(e,t,n)=>new Error("Missing field "+Jt(e,t,n)),Mt=(e,t,n)=>new Error("Invalid field "+Jt(e,t,n));async function Wt(e){if(se(e))try{let t=Yt(e);const n=It(Qt(e));await Promise.all(t.map(Vt(e,n)));let a=function(e){let t=new Set([e.payer]);return Array.from(t)}(e);const r=wt(O({},Qt(e),{payloadSigs:t.map(t=>({address:e.accounts[t].addr,keyId:e.accounts[t].keyId,sig:e.accounts[t].signature}))}));await Promise.all(a.map(Vt(e,r)))}catch(t){throw console.error("Signatures",t,{ix:e}),t}return e}function Yt(e){let t=new Set(e.authorizations);return t.add(e.proposer),t.delete(e.payer),Array.from(t)}function Vt(e,t){return async function(n){const a=e.accounts[n];if(null!=a.signature)return;const{signature:r}=await a.signingFunction(function(e,t,n){try{return{f_type:"Signable",f_vsn:"1.0.1",message:t,addr:E(e.addr),keyId:e.keyId,roles:e.role,cadence:n.message.cadence,args:n.message.arguments.map(e=>n.arguments[e].asArgument),data:{},interaction:n,voucher:Xt(n)}}catch(e){throw console.error("buildSignable",e),e}}(a,t,e));e.accounts[n].signature=r}}const Xt=e=>({cadence:e.message.cadence,refBlock:e.message.refBlock||null,computeLimit:e.message.computeLimit,arguments:e.message.arguments.map(t=>e.arguments[t].asArgument),proposalKey:{address:A(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:A(e.accounts[e.payer].addr),authorizers:e.authorizations.map(t=>A(e.accounts[t].addr)).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[]),payloadSigs:Yt(e).map(t=>({address:A(e.accounts[t].addr),keyId:e.accounts[t].keyId,sig:e.accounts[t].signature}))});function Qt(e){return{cadence:e.message.cadence,refBlock:e.message.refBlock||null,computeLimit:e.message.computeLimit,arguments:e.message.arguments.map(t=>e.arguments[t].asArgument),proposalKey:{address:E(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:E(e.accounts[e.payer].addr),authorizers:e.authorizations.map(t=>E(e.accounts[t].addr)).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[])}}function Zt(e,t){try{return{f_type:"PreSignable",f_vsn:"1.0.1",roles:e.role,cadence:t.message.cadence,args:t.message.arguments.map(e=>t.arguments[e].asArgument),data:{},interaction:t,voucher:Xt(t)}}catch(e){throw console.error("buildPreSignable",e),e}}async function en(t,n,a,r=3){e(r,"Account Resolve Recursion Limit Exceeded",{ix:t,accounts:n});let o=[];for(let e of n){var s=a||e;"function"==typeof e.resolve&&(e=await e.resolve(e,Zt(e,t))),Array.isArray(e)?await en(t,e,s,r-1):(t.accounts[e.tempId]=t.accounts[e.tempId]||e,t.accounts[e.tempId].role.proposer=t.accounts[e.tempId].role.proposer||e.role.proposer,t.accounts[e.tempId].role.payer=t.accounts[e.tempId].role.payer||e.role.payer,t.accounts[e.tempId].role.authorizer=t.accounts[e.tempId].role.authorizer||e.role.authorizer,t.accounts[e.tempId].role.proposer&&t.proposer===s.tempId&&(t.proposer=e.tempId),t.accounts[e.tempId].role.payer&&t.payer===s.tempId&&(t.payer=e.tempId),t.accounts[e.tempId].role.authorizer&&(a?o=[...o,e.tempId]:t.authorizations=t.authorizations.map(t=>t===s.tempId?e.tempId:t))),s.tempId!=e.tempId&&delete t.accounts[s.tempId]}a&&(t.authorizations=t.authorizations.map(e=>e===a.tempId?o:e).reduce((e,t)=>Array.isArray(t)?[...e,...t]:[...e,t],[]))}async function tn(e){if(se(e))try{await en(e,Object.values(e.accounts)),await en(e,Object.values(e.accounts))}catch(e){throw console.error("=== SAD PANDA ===\n\n",e,"\n\n=== SAD PANDA ==="),e}return e}async function nn(e){const t=ve(e,"ix.validators",[]);return Se(e,t.map(e=>t=>e(t,{Ok:P,Bad:F})))}async function an(e){for(let t of Object.keys(e.accounts))e.accounts[t].addr=E(e.accounts[t].addr);return e}const rn=Se([ht,bt,tn,async function(e){return se(e)&&null==e.message.refBlock&&(e.message.refBlock=(await nt(Ne([at()])).then(gt)).id),e},async function(t){if(se(t)){var n=Object.values(t.accounts).find(e=>e.role.proposer);e(n,"Transactions require a proposer"),null==n.sequenceNum&&(t.accounts[n.tempId].sequenceNum=await nt(await Ne([rt(n.addr)])).then(gt).then(e=>e.keys).then(e=>e.find(e=>e.index===n.keyId)).then(e=>e.sequenceNumber))}return t},Wt,an,nn]),on=async(e=[],t={})=>{const n=await He().get("sdk.send",t.send||nt),a=await He().get("sdk.resolve",t.resolve||rn);return Array.isArray(e)&&(e=Se(C(),e)),n(await a(e),t)};async function sn(e){const t=await He().where(/^decoder\./),n=Object.entries(t).map(([e,t])=>[e=`/${e.replace(/^decoder\./,"")}$/`,t]);return gt(e,Object.fromEntries(n))}class cn extends Error{constructor(e){super(`\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${e}. \n        Please ensure the address: ${e} is intended to sign the given transaction as specified by the transaction signable.\n      `.trim()),this.name="Unable To Determine Message Encoding For Signer Addresss"}}const un=(e,t)=>{let n=(e=>{let t=new Set(e.authorizers);return t.add(e.proposalKey.address),t.delete(e.payer),Array.from(t).map(A)})(e.voucher),a=(e=>{let t=new Set([e.payer]);return Array.from(t).map(A)})(e.voucher);const r=n.includes(A(t)),o=a.includes(A(t));if(!r&&!o)throw new cn(t);const s={cadence:e.voucher.cadence,refBlock:e.voucher.refBlock,computeLimit:e.voucher.computeLimit,arguments:e.voucher.arguments,proposalKey:O({},e.voucher.proposalKey,{address:E(e.voucher.proposalKey.address)}),payer:E(e.voucher.payer),authorizers:e.voucher.authorizers.map(E),payloadSigs:e.voucher.payloadSigs.map(e=>O({},e,{address:E(e.address)}))};return r?It(s):wt(s)};function ln(...e){let t=e[1]||("object"==typeof e[0]?e[0]:void 0),n="boolean"==typeof e[0]?e[0]:void 0;return"object"==typeof e[0]&&console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing options as the first arguement to the latestBlock function has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0007-deprecate-opts-first-arg-latest-block\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),on([at(n)],t).then(gt)}function dn(e,t){return on([rt(e)],t).then(gt)}function gn(e=[]){return Se(e.map(e=>j(e,{role:"authorizer"})))}function pn(e,t,n,a){return{addr:e,signingFunction:t,keyId:n,sequenceNum:a}}function fn(e){return Ae("ix.validators",t=>Array.isArray(t)?t.push(e):[e])}function mn(e){return Se([t=>(t.block.height=e,t),fn(e=>{if("boolean"==typeof e.block.isSealed)throw new Error("Unable to specify both block height and isSealed.");if(e.block.id)throw new Error("Unable to specify both block height and block id.");return e})])}function hn(e){return Se([t=>(t.block.id=e,P(t)),fn((e,{Ok:t,Bad:n})=>ue(e)?n(e,"Unable to specify a block id with a Get Account interaction."):"boolean"==typeof e.block.isSealed?n(e,"Unable to specify both block id and isSealed."):e.block.height?n(e,"Unable to specify both block id and block height."):t(e))])}function yn(e,t,n){return void 0===t&&void 0===n||console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),Se([Y,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,P(a))])}function kn(e,t,n){return Se([Y,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,P(a))])}function bn(e,t=[]){return Se([Y,n=>(n.events.eventType=e,n.events.blockIds=t,P(n))])}function In(e=null){return Se([te,t=>(t.block.isSealed=e,P(t))])}function wn(e=!1){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getLatestBlock builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0006-deprecate-get-latest-block-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),Se([V,t=>(t.block.isSealed=e,P(t))])}function Sn(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockById builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0004-deprecate-get-block-by-id-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),Se([X,t=>(t.block.ids=[e],P(t))])}function Bn(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockByHeight builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0003-deprecate-get-block-by-height-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),Se([Q,t=>(t.block.height=e,P(t))])}function vn(e=null){return Se([ne,t=>(t.collection.id=e,t)])}function En(e){return Se([$,t=>(t.transaction.id=e,P(t))])}function An(e){return Se([M,t=>(t.transaction.id=e,P(t))])}function Tn(e){return t=>(t.message.computeLimit=e,t)}function Nn(e=[]){return Se(e.map(z))}function xn(e,t){return{value:e,xform:t}}async function Ln(e){return j(e,{role:"proposer"})}async function On(e){return j(e,{role:"payer"})}function _n(){return Z}function Gn(e){return Se([t=>(t.message.refBlock=e,P(t))])}function Cn(...e){return Se([q,Ee("ix.cadence",L(...e))])}const Un=[];function Dn(...e){return Se([J,Ee("ix.cadence",L(...e)),e=>(e.message.computeLimit=e.message.computeLimit||10,e.message.refBlock=e.message.refBlock||null,e.authorizations=e.authorizations||Un,P(e))])}function Kn(...e){if(e.length>1){const[t,n]=e;return Kn((e,{Ok:a,Bad:r})=>t?a(e):r(e,n))}const[t]=e;return e=>t(e,{Ok:P,Bad:F})}const Rn=({node:e})=>async t=>{if(!se(t))return P(t);if(t.accounts[t.proposer].sequenceNum)return P(t);const n=await nt(await Ne([rt(t.accounts[t.proposer].addr)]),{node:e}),a=await gt(n);return t.accounts[t.proposer].sequenceNum=a.keys[t.accounts[t.proposer].keyId].sequenceNumber,P(t)},Pn="0.0.50",Fn=e=>{(({name:e,transitionsPath:t})=>{console.error(`\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The ${e} builder has been removed from the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: ${t}\n    ============================\n  `,"font-weight:bold;font-family:monospace;")})({name:"params",transitionsPath:"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"})},Hn=e=>(({name:e,transitionsPath:t})=>{console.warn(`\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The ${e} builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: ${t}\n    ============================\n  `,"font-weight:bold;font-family:monospace;")})({name:"param",transitionsPath:"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"});export{Pn as VERSION,dn as account,xn as arg,Nn as args,mn as atBlockHeight,hn as atBlockId,pn as authorization,gn as authorizations,Ne as build,He as config,Xt as createSignableVoucher,sn as decode,Te as destroy,un as encodeMessageFromSignable,ve as get,rt as getAccount,at as getBlock,Bn as getBlockByHeight,Sn as getBlockById,In as getBlockHeader,vn as getCollection,yn as getEvents,kn as getEventsAtBlockHeightRange,bn as getEventsAtBlockIds,wn as getLatestBlock,An as getTransaction,En as getTransactionStatus,C as interaction,Kn as invariant,be as isBad,ue as isGetAccount,me as isGetBlock,pe as isGetBlockByHeight,ge as isGetBlockById,he as isGetBlockHeader,ye as isGetCollection,le as isGetEvents,de as isGetLatestBlock,ie as isGetTransaction,ce as isGetTransactionStatus,ke as isOk,fe as isPing,oe as isScript,se as isTransaction,re as isUnknown,ln as latestBlock,Tn as limit,Hn as param,Fn as params,On as payer,_n as ping,Se as pipe,Ln as proposer,Ee as put,Gn as ref,rn as resolve,tn as resolveAccounts,bt as resolveArguments,ht as resolveCadence,an as resolveFinalNormalization,Rn as resolveProposerSequenceNumber,pt as resolveRefBlockId,Wt as resolveSignatures,nn as resolveValidators,Cn as script,on as send,Dn as transaction,Ae as update,fn as validator,Ie as why};
//# sourceMappingURL=sdk.modern.js.map
