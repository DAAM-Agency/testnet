{"version":3,"file":"index.js","sources":["../src/config.js","../src/address.js","../src/crypto.js","../src/utils.js","../src/interaction.js","../src/generated/transactions/createAccount.js","../src/generated/transactions/deployContract.js","../src/generated/transactions/initManager.js","../src/generated/transactions/mintTokens.js","../src/generated/transactions/registerContract.js","../src/generated/transactions/scratch.js","../src/generated/transactions/setBlockOffset.js","../src/generated/transactions/updateContract.js","../src/generated/transactions/index.js","../src/deploy-code.js","../src/generated/contracts/FlowManager.js","../src/generated/scripts/checkManager.js","../src/generated/scripts/getAccountAddress.js","../src/generated/scripts/getBalance.js","../src/generated/scripts/getBlockOffset.js","../src/generated/scripts/getContractAddress.js","../src/generated/scripts/index.js","../src/generated/index.js","../src/manager.js","../src/contract.js","../src/imports.js","../src/file.js","../src/templates.js","../src/jest-asserts.js","../src/emulator.js","../src/transformers.js","../src/account.js","../src/flow-token.js","../src/init.js"],"sourcesContent":["/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { flowConfig } from \"@onflow/fcl-config\";\nimport { config } from \"@onflow/config\";\n\n/**\n * Get value from provided scope and path.\n * @param scope - scope value.\n * @param path - value path in config (flow.json) file.\n * @param fallback - fallback value.\n * @returns {*} - value at specified scope and path.\n */\nexport const get = (scope, path, fallback) => {\n  if (typeof path === \"string\") return get(scope, path.split(\"/\"), fallback);\n  if (!path.length) return scope;\n  try {\n    const [head, ...rest] = path;\n    return get(scope[head], rest, fallback);\n  } catch (_error) {\n    return fallback;\n  }\n};\n\n/**\n * Set globally available config value.\n * @param {string} key - key to be used to access stored value.\n * @param {string} env - value key in the environment (for example .env file).\n * @param {string} conf - value path in config (flow.json) file.\n * @param fallback - fallback value to be used if env and conf are absent.\n */\nexport const set = (key, env, conf, fallback) => {\n  let value = get(flowConfig(), conf, fallback);\n  if (!value) {\n    value = fallback;\n  }\n  config().put(key, value);\n};\n\n/**\n * Returns config value at specified key.\n * @param key - key to the value.\n * @returns {Promise<*>} - value at specified key.\n */\nexport const getConfigValue = async (key) => {\n  return config().get(key);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = (address) => {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\");\n};\n\nexport const withPrefix = (address) => {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ec as EC } from \"elliptic\";\nimport { SHA3 } from \"sha3\";\nimport * as fcl from \"@onflow/fcl\";\nimport * as rlp from \"rlp\";\nimport { config } from \"@onflow/config\";\nimport { sansPrefix, withPrefix } from \"./address\";\nconst ec = new EC(\"p256\");\n\nconst hashMsgHex = (msgHex) => {\n  const sha = new SHA3(256);\n  sha.update(Buffer.from(msgHex, \"hex\"));\n  return sha.digest();\n};\n\nexport const signWithKey = (privateKey, msgHex) => {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, \"hex\"));\n  const sig = key.sign(hashMsgHex(msgHex));\n  const n = 32; // half of signature length?\n  const r = sig.r.toArrayLike(Buffer, \"be\", n);\n  const s = sig.s.toArrayLike(Buffer, \"be\", n);\n  return Buffer.concat([r, s]).toString(\"hex\");\n};\n\nexport const authorization =\n  (addr, keyId = 0) =>\n  async (account = {}) => {\n    const serviceAddress = await config().get(\"SERVICE_ADDRESS\");\n    const pkey = await config().get(\"PRIVATE_KEY\");\n\n    addr = sansPrefix(addr || serviceAddress);\n\n    const signingFunction = async (data) => ({\n      keyId,\n      addr: withPrefix(addr),\n      signature: signWithKey(pkey, data.message),\n    });\n\n    return {\n      ...account,\n      tempId: `${addr}-${keyId}`,\n      addr: fcl.sansPrefix(addr),\n      keyId,\n      signingFunction,\n    };\n  };\n\nexport const pubFlowKey = async () => {\n  const keys = ec.keyFromPrivate(Buffer.from(await config().get(\"PRIVATE_KEY\"), \"hex\"));\n  const publicKey = keys.getPublic(\"hex\").replace(/^04/, \"\");\n  return rlp\n    .encode([\n      Buffer.from(publicKey, \"hex\"), // publicKey hex to binary\n      2, // P256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      3, // SHA3-256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      1000, // give key full weight\n    ])\n    .toString(\"hex\");\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const isObject = (arg) => typeof arg === \"object\" && arg !== null;\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\";\nimport { resolveArguments } from \"flow-cadut\";\nimport { authorization } from \"./crypto\";\nimport { getTransactionCode, getScriptCode, defaultsByName } from \"./file\";\nimport { resolveImports, replaceImportAddresses } from \"./imports\";\nimport { getServiceAddress } from \"./manager\";\nimport { isObject } from \"./utils\";\n\nconst DEFAULT_LIMIT = 999;\n\nexport const extractParameters = (ixType) => {\n  return async (params) => {\n    let ixCode, ixName, ixSigners, ixArgs, ixService, ixTransformers, ixLimit;\n\n    if (isObject(params[0])) {\n      const [props] = params;\n      const { name, code, args, signers, transformers, limit, service = false } = props;\n\n      ixService = service;\n\n      if (!name && !code) {\n        throw Error(\"Both `name` and `code` are missing. Provide either of them\");\n      }\n      ixName = name;\n      ixCode = code;\n\n      ixSigners = signers;\n      ixArgs = args;\n      ixTransformers = transformers || [];\n      ixLimit = limit;\n    } else {\n      if (ixType === \"script\") {\n        [ixName, ixArgs, ixLimit, ixTransformers] = params;\n      } else {\n        [ixName, ixSigners, ixArgs, ixLimit, ixTransformers] = params;\n      }\n    }\n\n    // Check that limit is always set\n    ixLimit = ixLimit || DEFAULT_LIMIT;\n\n    if (ixName) {\n      const getIxTemplate = ixType === \"script\" ? getScriptCode : getTransactionCode;\n      ixCode = await getIxTemplate({ name: ixName });\n    }\n\n    // We need a way around to allow initial scripts and transactions for Manager contract\n    let deployedContracts;\n    if (ixService) {\n      deployedContracts = defaultsByName;\n    } else {\n      deployedContracts = await resolveImports(ixCode);\n    }\n\n    const serviceAddress = await getServiceAddress();\n    const addressMap = {\n      ...defaultsByName,\n      ...deployedContracts,\n      FlowManager: serviceAddress,\n    };\n\n    ixCode = replaceImportAddresses(ixCode, addressMap);\n\n    // Apply all the necessary transformations to the code\n    for (const i in ixTransformers) {\n      const transformer = ixTransformers[i];\n      ixCode = await transformer(ixCode);\n    }\n\n    return {\n      code: ixCode,\n      signers: ixSigners,\n      args: ixArgs,\n      limit: ixLimit,\n    };\n  };\n};\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n * @param {string} [props.name] - Name of Cadence template file\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {string} [props.code] - Cadence code of the transaction.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @param {[string]} [props.signers] - list of signers, who will authorize transaction, specified as array of addresses.\n * @returns {Promise<any>}\n */\n\nexport const sendTransaction = async (...props) => {\n  try {\n    const extractor = extractParameters(\"tx\");\n    const { code, args, signers, limit } = await extractor(props);\n\n    const serviceAuth = authorization();\n\n    // set repeating transaction code\n    const ix = [\n      fcl.transaction(code),\n      fcl.payer(serviceAuth),\n      fcl.proposer(serviceAuth),\n      fcl.limit(limit),\n    ];\n\n    // use signers if specified\n    if (signers) {\n      const auths = signers.map((address) => authorization(address));\n      ix.push(fcl.authorizations(auths));\n    } else {\n      // and only service account if no signers\n      ix.push(fcl.authorizations([serviceAuth]));\n    }\n\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code);\n      ix.push(fcl.args(resolvedArgs));\n    }\n    const response = await fcl.send(ix);\n    const result = await fcl.tx(response).onceExecuted();\n\n    return [result, null];\n  } catch (e) {\n    return [null, e];\n  }\n};\n\n/**\n * Sends script code for execution. Returns decoded value\n * @param {string} props.code - Cadence code of the script to be submitted.\n * @param {string} props.name - name of the file to source code from.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @returns {Promise<*>}\n */\n\nexport const executeScript = async (...props) => {\n  try {\n    const extractor = extractParameters(\"script\");\n    const { code, args, limit } = await extractor(props);\n\n    const ix = [fcl.script(code), fcl.limit(limit)];\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code);\n      ix.push(fcl.args(resolvedArgs));\n    }\n    const response = await fcl.send(ix);\n    const result = await fcl.decode(response);\n    return [result, null];\n  } catch (e) {\n    return [null, e];\n  }\n};\n","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\r\n\r\ntransaction (_ name: String, pubKey: String, manager: Address) {\r\n    prepare( admin: AuthAccount) {\r\n        let newAccount = AuthAccount(payer:admin)\r\n        newAccount.addPublicKey(pubKey.decodeHex())\r\n\r\n        let linkPath = FlowManager.accountManagerPath\r\n        let accountManager = getAccount(manager)\r\n                            .getCapability(linkPath)!\r\n                            .borrow<&FlowManager.Mapper>()!\r\n        \r\n        // Create a record in account database\r\n        let address = newAccount.address\r\n        accountManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for createAccount transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const createAccountTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `createAccount =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends createAccount transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const createAccount = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await createAccountTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `createAccount =>`);\n  reportMissing(\"signers\", signers.length, 1, `createAccount =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction,\n} from 'flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for deployContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const deployContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `deployContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends deployContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const deployContract = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await deployContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `deployContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `deployContract =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: \"FlowManager\",\n           code: code.decodeHex(),\n        )\n   }\n  }\n`;\n\n/**\n* Method to generate cadence code for initManager transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const initManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `initManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends initManager transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const initManager = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await initManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `initManager =>`);\n  reportMissing(\"signers\", signers.length, 1, `initManager =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for mintTokens transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const mintTokensTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `mintTokens =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends mintTokens transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const mintTokens = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await mintTokensTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `mintTokens =>`);\n  reportMissing(\"signers\", signers.length, 1, `mintTokens =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\r\n\r\ntransaction(name: String, address: Address) {\r\n    prepare(signer: AuthAccount){\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = signer\r\n                                .getCapability(linkPath)!\r\n                                .borrow<&FlowManager.Mapper>()!\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for registerContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const registerContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `registerContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends registerContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const registerContract = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await registerContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `registerContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `registerContract =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  transaction{\r\n    prepare(acct: AuthAccount){\r\n        log(acct.address)\r\n    }\r\n}\n`;\n\n/**\n* Method to generate cadence code for scratch transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const scratchTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `scratch =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends scratch transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const scratch = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await scratchTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `scratch =>`);\n  reportMissing(\"signers\", signers.length, 1, `scratch =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setBlockOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setBlockOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setBlockOffset = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setBlockOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setBlockOffset =>`);\n\n  return sendTransaction({code, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for updateContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const updateContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `updateContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends updateContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const updateContract = async (props) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await updateContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `updateContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `updateContract =>`);\n\n  return sendTransaction({code, ...props})\n}","import { createAccountTemplate, createAccount } from \"./createAccount\";\nimport { deployContractTemplate, deployContract } from \"./deployContract\";\nimport { initManagerTemplate, initManager } from \"./initManager\";\nimport { mintTokensTemplate, mintTokens } from \"./mintTokens\";\nimport { registerContractTemplate, registerContract } from \"./registerContract\";\nimport { scratchTemplate, scratch } from \"./scratch\";\nimport { setBlockOffsetTemplate, setBlockOffset } from \"./setBlockOffset\";\nimport { updateContractTemplate, updateContract } from \"./updateContract\";\n\nexport default {\n  createAccountTemplate,\n  createAccount,\n  deployContractTemplate,\n  deployContract,\n  initManagerTemplate,\n  initManager,\n  mintTokensTemplate,\n  mintTokens,\n  registerContractTemplate,\n  registerContract,\n  scratchTemplate,\n  scratch,\n  setBlockOffsetTemplate,\n  setBlockOffset,\n  updateContractTemplate,\n  updateContract,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { sendTransaction } from \"./interaction\";\nimport { getServiceAddress } from \"./manager\";\nimport { defaultsByName, getContractCode } from \"./file\";\n\nimport txRegistry from \"./generated/transactions\";\nimport { isObject } from \"./utils\";\nimport { extractContractParameters, generateSchema, splitArgs } from \"flow-cadut\";\nimport { replaceImportAddresses, resolveImports } from \"./imports\";\n\nconst { updateContractTemplate, deployContractTemplate } = txRegistry;\n\nexport const hexContract = (contract) => Buffer.from(contract, \"utf8\").toString(\"hex\");\n\nconst extractParameters = async (params) => {\n  let ixName, ixTo, ixAddressMap, ixArgs, ixUpdate;\n\n  if (isObject(params[0])) {\n    const [props] = params;\n    const { name, to, addressMap, args, update } = props;\n\n    if (!name) {\n      throw Error(\"'name' field is missing\");\n    }\n\n    ixName = name;\n    ixTo = to;\n    ixArgs = args;\n    ixAddressMap = addressMap;\n    ixUpdate = update;\n  } else {\n    [ixName, ixTo, ixAddressMap, ixArgs, ixUpdate] = params;\n  }\n\n  const serviceAddress = await getServiceAddress();\n  const addressMap = {\n    ...defaultsByName,\n    FlowManager: serviceAddress,\n    ...ixAddressMap,\n  };\n\n  return {\n    name: ixName,\n    to: ixTo,\n    args: ixArgs,\n    update: ixUpdate,\n    addressMap,\n  };\n};\n\n/**\n * Deploys a contract by name to specified account\n * Returns transaction result.\n * @param {string} props.to - If no address is supplied, the contract will be deployed to the emulator service account.\n * @param {string} props.name  - The name of the contract to look for. This should match a .cdc file located at the specified `basePath`.\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced.\n * @returns {Promise<any>}\n */\nexport const deployContractByName = async (...props) => {\n  const params = await extractParameters(props);\n  const { to, name, addressMap, args, update = false } = params;\n\n  const resolvedAddress = to || (await getServiceAddress());\n  const contractCode = await getContractCode({ name, addressMap });\n\n  const ixName = /[\\\\\\/]/.test(name) ? null : name;\n\n  return deployContract({\n    to: resolvedAddress,\n    code: contractCode,\n    name: ixName,\n    args,\n    update,\n  });\n};\n\n/**\n * Deploys contract as Cadence code to specified account\n * Returns transaction result.\n * @param {string} props.code - Cadence code for contract to be deployed\n * @param {string} props.to - If no address is supplied, the contract\n * will be deployed to the emulator service account\n * @param {string} props.name  - The name of the contract to look for. This should match\n * a .cdc file located at the specified `basePath`\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced\n */\nexport const deployContract = async (props) => {\n  const { to, code: contractCode, name, args, update } = props;\n\n  const params = await extractContractParameters(contractCode);\n  const ixName = name || params.contractName;\n\n  // TODO: extract name from contract code\n  const containerAddress = to || (await getServiceAddress());\n  const managerAddress = await getServiceAddress();\n\n  // Replace import addresses, before hexing contract code\n  const deployedContracts = await resolveImports(contractCode);\n  const serviceAddress = await getServiceAddress();\n  const addressMap = {\n    ...defaultsByName,\n    ...deployedContracts,\n    FlowManager: serviceAddress,\n  };\n\n  const hexedCode = hexContract(replaceImportAddresses(contractCode, addressMap));\n\n  let code = update\n    ? await updateContractTemplate(addressMap)\n    : await deployContractTemplate(addressMap);\n\n  let deployArgs = [ixName, hexedCode, managerAddress];\n\n  if (args) {\n    deployArgs = deployArgs.concat(args);\n    const schema = generateSchema(params.args).map((item) => splitArgs(item)[0]);\n\n    const argLetter = \"abcdefghijklmnopqrstuvwxyz\";\n    let argList = [];\n    for (let i = 0; i < schema.length; i++) {\n      const value = schema[i];\n      argList.push(`${argLetter[i]}: ${value}`);\n    }\n\n    code = code.replace(\"##ARGS-WITH-TYPES##\", `, ${params.args}`);\n    code = code.replace(\"##ARGS-LIST##\", argList);\n  } else {\n    code = code.replace(\"##ARGS-WITH-TYPES##\", ``);\n    code = code.replace(\"##ARGS-LIST##\", \"\");\n  }\n\n  const signers = [containerAddress];\n\n  return sendTransaction({\n    code,\n    args: deployArgs,\n    signers,\n  });\n};\n","/** pragma type contract **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  deployContract,\n} from 'flow-cadut'\n\nexport const CODE = `\n  pub contract FlowManager {\r\n\r\n    /// Account Manager\r\n    pub event AccountAdded(address: Address)\r\n\r\n    pub struct Mapper {\r\n        pub let accounts: {String: Address}\r\n\r\n        pub fun getAddress(_ name: String): Address? {\r\n            return self.accounts[name]\r\n        }\r\n\r\n        pub fun setAddress(_ name: String, address: Address){\r\n            self.accounts[name] = address\r\n            emit FlowManager.AccountAdded(address: address)\r\n        }\r\n\r\n        init(){\r\n            self.accounts = {}\r\n        }\r\n    }\r\n\r\n    pub fun getAccountAddress(_ name: String): Address?{\r\n        let accountManager = self.account\r\n            .getCapability(self.accountManagerPath)\r\n            .borrow<&FlowManager.Mapper>()!\r\n\r\n        return accountManager.getAddress(name)\r\n    }\r\n\r\n    pub let defaultAccounts: {Address : String}\r\n\r\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\r\n        let alias = self.defaultAccounts[address]!\r\n        return self.getAccountAddress(alias)!\r\n    }\r\n\r\n    pub let accountManagerStorage: StoragePath\r\n    pub let contractManagerStorage: StoragePath\r\n    pub let accountManagerPath: PublicPath\r\n    pub let contractManagerPath: PublicPath\r\n\r\n    /// Environment Manager\r\n    pub event BlockOffsetChanged(offset: UInt64)\r\n\r\n    pub struct MockBlock {\r\n        pub let id: [UInt8; 32]\r\n        pub let height: UInt64\r\n        pub let view: UInt64\r\n        pub let timestamp: UFix64\r\n\r\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\r\n            self.id = id\r\n            self.height = height\r\n            self.view = view\r\n            self.timestamp = timestamp\r\n        }\r\n    }\r\n\r\n    pub fun setBlockOffset(_ offset: UInt64){\r\n        self.blockOffset = offset\r\n        emit FlowManager.BlockOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun getBlockHeight(): UInt64 {\r\n        var block = getCurrentBlock()\r\n        return block.height + self.blockOffset\r\n    }\r\n\r\n    pub fun getBlock(): MockBlock {\r\n        var block =  getCurrentBlock()\r\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\r\n        return mockBlock\r\n    }\r\n\r\n    pub var blockOffset: UInt64;\r\n\r\n\r\n    // Initialize contract\r\n    init(){\r\n        // Environment defaults\r\n        self.blockOffset = 0;\r\n\r\n        // Account Manager initialization\r\n        let accountManager = Mapper()\r\n        let contractManager = Mapper()\r\n\r\n        self.defaultAccounts = {\r\n          0x01: \"Alice\",\r\n          0x02: \"Bob\",\r\n          0x03: \"Charlie\",\r\n          0x04: \"Dave\",\r\n          0x05: \"Eve\"\r\n        }\r\n\r\n        self.accountManagerStorage = /storage/testSuitAccountManager\r\n        self.contractManagerStorage = /storage/testSuitContractManager\r\n\r\n        self.accountManagerPath = /public/testSuitAccountManager\r\n        self.contractManagerPath = /public/testSuitContractManager\r\n        \r\n        // Destroy previously stored values\r\n        self.account.load<Mapper>(from: self.accountManagerStorage)\r\n        self.account.load<Mapper>(from: self.contractManagerStorage)\r\n\r\n        self.account.save(accountManager, to: self.accountManagerStorage)\r\n        self.account.save(contractManager, to: self.contractManagerStorage)\r\n\r\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\r\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\r\n    }\r\n}\r\n \n`;\n\n/**\n* Method to generate cadence code for FlowManager transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const FlowManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `FlowManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Deploys FlowManager transaction to the network\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> args - list of arguments\n* param Array<string> - list of signers\n*/\nexport const  deployFlowManager = async (props) => {\n  const { addressMap = {} } = props;\n  const code = await FlowManagerTemplate(addressMap);\n  const name = \"FlowManager\"\n\n  return deployContract({ code, name, ...props })\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n`;\n\n/**\n* Method to generate cadence code for TestAsset\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const checkManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `checkManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const checkManager = async (props) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await checkManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `checkManager =>`);\n\n  return executeScript({code, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.accountManagerPath\r\n    let accountManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return accountManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for TestAsset\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getAccountAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getAccountAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getAccountAddress = async (props) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getAccountAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getAccountAddress =>`);\n\n  return executeScript({code, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from 'flow-cadut'\n\nexport const CODE = `\n  // This script reads the balance field of an account's FlowToken Balance\r\n\r\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\r\nimport ExampleToken from 0xTOKENADDRESS\r\n\r\npub fun main(account: Address): UFix64 {\r\n    let acct = getAccount(account)\r\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\r\n        ?? panic(\"Could not borrow Balance reference to the Vault\")\r\n\r\n    return vaultRef.balance\r\n}\n`;\n\n/**\n* Method to generate cadence code for TestAsset\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBalanceTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBalance =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBalance = async (props) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBalanceTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `getBalance =>`);\n\n  return executeScript({code, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for TestAsset\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBlockOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getBlockOffset =>`);\n\n  return executeScript({code, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from 'flow-cadut'\n\nexport const CODE = `\n  import FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.contractManagerPath\r\n    let contractManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return contractManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for TestAsset\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getContractAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getContractAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getContractAddress = async (props) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getContractAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getContractAddress =>`);\n\n  return executeScript({code, ...props})\n}","import { checkManagerTemplate, checkManager } from \"./checkManager\";\nimport { getAccountAddressTemplate, getAccountAddress } from \"./getAccountAddress\";\nimport { getBalanceTemplate, getBalance } from \"./getBalance\";\nimport { getBlockOffsetTemplate, getBlockOffset } from \"./getBlockOffset\";\nimport { getContractAddressTemplate, getContractAddress } from \"./getContractAddress\";\nimport { getManagerAddressTemplate, getManagerAddress } from \"./getManagerAddress\";\n\nexport default {\n  checkManagerTemplate,\n  checkManager,\n  getAccountAddressTemplate,\n  getAccountAddress,\n  getBalanceTemplate,\n  getBalance,\n  getBlockOffsetTemplate,\n  getBlockOffset,\n  getContractAddressTemplate,\n  getContractAddress,\n  getManagerAddressTemplate,\n  getManagerAddress,\n};\n","import contracts from \"./contracts\";\nimport scripts from \"./scripts\";\nimport transactions from \"./transactions\";\n\nexport default {\n  contracts,\n  scripts,\n  transactions,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { config } from \"@onflow/config\";\nimport { withPrefix } from \"./address\";\nimport { hexContract } from \"./deploy-code\";\nimport registry from \"./generated\";\n\nexport const initManager = async () => {\n  const code = await registry.transactions.initManagerTemplate();\n  const contractCode = await registry.contracts.FlowManagerTemplate();\n  const hexedContract = hexContract(contractCode);\n  const args = [hexedContract];\n\n  await sendTransaction({\n    code,\n    args,\n    service: true,\n  });\n};\n\nexport const getServiceAddress = async () => {\n  return withPrefix(await config().get(\"SERVICE_ADDRESS\"));\n};\n\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const addressMap = {\n    FlowManager: serviceAddress,\n  };\n\n  const code = await registry.scripts.checkManagerTemplate(addressMap);\n\n  let [result, e] = await executeScript({\n    code,\n    service: true,\n  });\n  if (e && result === null) {\n    await initManager();\n  }\n\n  return getServiceAddress();\n};\n\n// TODO: replace method above after Cadence will allow to get contracts list on PublicAccount\n/*\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const code = `\n    pub fun main(address: Address):Bool {\n      return getAccount(address).contracts.get(\"FlowManager\") != null\n    }\n  `;\n  const result = await executeScript({ code, args: [serviceAddress] });\n\n  if (!result) {\n    await initManager();\n  }\n\n  return serviceAddress;\n};\n */\n\nexport const getBlockOffset = async () => {\n  const FlowManager = await getManagerAddress();\n  const code = await registry.scripts.getBlockOffsetTemplate({ FlowManager });\n  return executeScript({ code });\n};\n\nexport const setBlockOffset = async (offset) => {\n  const FlowManager = await getManagerAddress();\n\n  const args = [offset];\n  const code = await registry.transactions.setBlockOffsetTemplate({ FlowManager });\n  const payer = [FlowManager];\n\n  return sendTransaction({ code, args, payer });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getManagerAddress } from \"./manager\";\nimport { executeScript } from \"./interaction\";\nimport { defaultsByName } from \"./file\";\n\nimport registry from \"./generated\";\n\n/**\n * Returns address of the account where contract specified by name is currently deployed\n * @param {string} name - name of the account to look for\n * @param {boolean} [useDefaults=false] - whether we shall look into default addressed first\n * @returns {Promise<string>}\n */\nexport const getContractAddress = async (name, useDefaults = false) => {\n  // TODO: Maybe try to automatically deploy contract? \n\n  if (useDefaults) {\n    const defaultContract = defaultsByName[name];\n    if (defaultContract !== undefined) {\n      return defaultContract;\n    }\n  }\n\n  const managerAddress = await getManagerAddress();\n  const addressMap = { FlowManager: managerAddress };\n\n  const code = await registry.scripts.getContractAddressTemplate(addressMap);\n  const args = [name, managerAddress];\n  const [contractAddress] = await executeScript({\n    code,\n    args,\n    service: true,\n  });\n\n  return contractAddress;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getContractAddress } from \"./contract\";\nimport { defaultsByName } from \"./file\";\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g;\n\nconst getPairs = (line) => {\n  return line\n    .split(/\\s/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item.length > 0 && item !== \"import\" && item !== \"from\");\n};\n\nconst collect = (acc, item) => {\n  const [contract, address] = item;\n  acc[contract] = address;\n  return acc;\n};\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = (code) => {\n  if (!code || code.length === 0) {\n    return {};\n  }\n  return code\n    .split(\"\\n\")\n    .filter((line) => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {});\n};\n\nexport const replaceImports = (code, addressMap) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract) => {\n    const newAddress = addressMap instanceof Function ? addressMap(contract) : addressMap[contract];\n    return `${imp}${contract} from ${newAddress}`;\n  });\n};\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address;\n    const newAddress = addressMap instanceof Function ? addressMap(key) : addressMap[key];\n    return `${imp}${contract} from ${newAddress}`;\n  });\n};\n\n/**\n * Resolves import addresses defined in code template\n * @param {string} code - Cadence template code.\n * @returns {{string:string}} - name/address map\n */\nexport const resolveImports = async (code) => {\n  const addressMap = {};\n  const importList = extractImports(code);\n  for (const key in importList) {\n    if (defaultsByName[key]) {\n      addressMap[key] = defaultsByName[key];\n    } else {\n      const address = await getContractAddress(key);\n      addressMap[key] = address;\n    }\n  }\n  return addressMap;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport { config } from \"@onflow/config\";\n\nimport { replaceImportAddresses } from \"./imports\";\nimport { isObject } from \"./utils\";\n\nexport const readFile = (path) => {\n  return fs.readFileSync(path, \"utf8\");\n};\n\n/**\n * Address map with access by name for contracts deployed to emulator by default.\n * @type {{FlowFees: string, FlowToken: string, FungibleToken: string}}\n */\nexport const defaultsByName = {\n  FlowToken: \"0x0ae53cb6e3f42a79\",\n  FungibleToken: \"0xee82856bf20e2aa6\",\n  FlowFees: \"0xe5a8b7f23e8b548f\",\n  FlowStorageFees: \"0xf8d6e0586b0a20c7\",\n};\n\n/**\n * Address map with access by address for contracts deployed to emulator by default.\n * @type {{\"0xe5a8b7f23e8b548f\": string, \"0xf8d6e0586b0a20c7\": string, \"0xee82856bf20e2aa6\": string, \"0x0ae53cb6e3f42a79\": string}}\n */\nexport const defaultsByAddress = {\n  \"0xe5a8b7f23e8b548f\": \"0xe5a8b7f23e8b548f\", // FlowFees\n  \"0xf8d6e0586b0a20c7\": \"0xf8d6e0586b0a20c7\", // FlowStorageFees\n  \"0x0ae53cb6e3f42a79\": \"0x0ae53cb6e3f42a79\", // FlowToken\n  \"0xee82856bf20e2aa6\": \"0xee82856bf20e2aa6\", // FungibleToken\n};\n\nconst SCRIPT = \"scripts\";\nconst TRANSACTION = \"transactions\";\nconst CONTRACT = \"contracts\";\n\nexport const templateType = {\n  SCRIPT,\n  TRANSACTION,\n  CONTRACT,\n};\n\nexport const getPath = async (name, type = TRANSACTION) => {\n  const configBase = await config().get(\"BASE_PATH\");\n\n  // We can simply overwrite \"configBase\" variable, but I believe it's better to leave it unchanged\n  let basePath = configBase;\n\n  // It's possible to pass a set of paths via object, so we need to check if that's the case\n  if (isObject(configBase)) {\n    const typePath = configBase[type];\n\n    // if there is a specific path for this type, then we shall resolve it\n    if (typePath) {\n      return path.resolve(typePath, `./${name}.cdc`);\n    }\n\n    // otherwise use \"base\" value\n    basePath = configBase.base;\n  }\n\n  return path.resolve(basePath, `./${type}/${name}.cdc`);\n};\n\n/**\n * Returns Cadence template for specified file. Replaces imports using provided address map\n * @param file - name of the file to look for.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [byAddress=false] - flag to indicate if address map is address to address type.\n * @returns {string}\n */\nexport const getTemplate = (file, addressMap = {}, byAddress = false) => {\n  const rawCode = readFile(file);\n\n  const defaults = byAddress ? defaultsByAddress : defaultsByName;\n\n  return addressMap\n    ? replaceImportAddresses(rawCode, {\n        ...defaults,\n        ...addressMap,\n      })\n    : rawCode;\n};\n\n/**\n * Returns contract template using name of the file in \"contracts\" folder containing the code.\n * @param name - name of the contract template in \"contract\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getContractCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.CONTRACT);\n  return getTemplate(path, addressMap);\n};\n\n/**\n * Returns transaction template using name of the file in \"transactions\" folder containing the code.\n * @param name - name of the transaction template in \"transactions\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getTransactionCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.TRANSACTION);\n  return getTemplate(path, addressMap);\n};\n\n/**\n * Returns script template using name of the file in \"scripts\" folder containing the code.\n * @param name - name of the script template in \"scripts\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getScriptCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.SCRIPT);\n  return getTemplate(path, addressMap);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport registry from \"./generated\";\nimport { defaultsByName } from \"./file\";\n\nconst FlowTokenMap = { ExampleToken: defaultsByName.FlowToken };\n\nconst lowerFirst = (name) => {\n  return name[0].toLowerCase() + name.slice(1);\n};\n\nexport const makeMintTransaction = async (name) => {\n  const code = await registry.transactions.mintTokensTemplate(FlowTokenMap);\n  const pattern = /(ExampleToken)/gi;\n\n  return code.replace(pattern, (match) => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name);\n  });\n};\n\nexport const makeGetBalance = async (name) => {\n  const code = await registry.scripts.getBalanceTemplate(FlowTokenMap);\n  const pattern = /(ExampleToken)/gi;\n\n  return code.replace(pattern, (match) => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name);\n  });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { expect } = global;\n\n/**\n * Return Promise from passed interaction\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*>\n * */\nexport const promise = async (ix) => {\n  if (typeof ix === \"function\") {\n    return await ix();\n  }\n  return await ix;\n};\n\n/**\n * Ensure transaction did not throw and sealed.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - transaction result\n * */\nexport const shallPass = async (ix) => {\n  const wrappedInteraction = promise(ix);\n\n  const response = await wrappedInteraction;\n  const [result, error] = response;\n\n  if (error) {\n    throw error;\n  }\n\n  let resolvedStatus;\n  let resolvedErrorMessage;\n  if (Array.isArray(result)) {\n    const { status, errorMessage } = result;\n    resolvedStatus = status;\n    resolvedErrorMessage = errorMessage;\n  } else {\n    const { status, errorMessage } = result;\n    resolvedStatus = status;\n    resolvedErrorMessage = errorMessage;\n  }\n\n  await expect(resolvedStatus).toBe(4);\n  await expect(resolvedErrorMessage).toBe(\"\");\n\n  return response;\n};\n\n/**\n * Ensure interaction did not throw and return result of it\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - result of interaction\n * */\nexport const shallResolve = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  const response = await wrappedInteraction;\n  const [, error] = response;\n  expect(error).toBe(null);\n\n  return response;\n};\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallRevert = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  const response = await wrappedInteraction;\n  const [result, error] = response;\n  await expect(result).toBe(null);\n  await expect(error).not.toBe(null);\n\n  return response;\n};\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallThrow = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  const response = await wrappedInteraction;\n\n  const [result, error] = response;\n  await expect(result).toBe(null);\n  await expect(error).not.toBe(null);\n\n  return response;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { send, build, getBlock, decode } from \"@onflow/fcl\";\nimport { config } from \"@onflow/config\";\n\nconst { spawn } = require(\"child_process\");\n\nconst DEFAULT_HTTP_PORT = 8080;\nconst DEFAULT_GRPC_PORT = 3569;\n\nconst print = {\n  \"log\": console.log,\n  \"service\": console.log,\n  \"info\": console.log,\n  \"error\": console.error,\n  \"warn\": console.warn\n}\n\n/** Class representing emulator */\nexport class Emulator {\n  /**\n   * Create an emulator.\n   */\n  constructor() {\n    this.initialized = false;\n    this.logging = false;\n    this.filters = [];\n    this.logProcessor = (item) => item;\n  }\n\n  /**\n   * Set logging flag.\n   * @param {boolean} logging - whether logs shall be printed\n   */\n  setLogging(logging) {\n    this.logging = logging;\n  }\n\n  /**\n   * Log message with a specific type.\n   * @param {*} message - message to put into log output\n   * @param {\"log\"|\"error\"} type - type of the message to output\n   */\n  log(message, type = \"log\") {\n    if (this.logging !== false) {\n      print[type](message);\n    }\n  }\n\n  checkLevel(message, level){\n    if(level === \"debug\"){\n      // We might need to find a better way for this, but this will do for now...\n      return message.includes(\"LOG\") ? \"log\" : level\n    }\n    return level\n  }\n\n  extractKeyValue(str) {\n    // TODO: add regexp check that it conforms to necessary pattern\n    const [key, value] = str.split(\"=\");\n    if (value.includes(\"LOG\")) {\n      return { key, value: value.replace(`\"\\x1b[1;34m`, `\"\\x1b[1[34m`) };\n    }\n    return { key, value };\n  }\n\n  fixJSON(msg) {\n    const splitted = msg.split(\"\\n\").filter((item) => item !== \"\");\n    const reconstructed = splitted.length > 1 ? `[${splitted.join(\",\")}]` : splitted[0];\n    return reconstructed;\n  }\n\n  parseDataBuffer(data) {\n    const message = data.toString();\n    try {\n      if (message.includes(\"msg\")) {\n        return JSON.parse(this.fixJSON(message));\n      }\n    } catch (e) {\n      console.error(e);\n      return { msg: e, level: \"JSON Error\" };\n    }\n    return { msg: message, level: \"parser\" };\n  }\n\n  /**\n   * Start emulator.\n   * @param {number} port - port to use for accessApi\n   * @param {boolean} logging - whether logs shall be printed\n   * @returns Promise<*>\n   */\n  async start(port = DEFAULT_HTTP_PORT, options = {}) {\n    // config access node\n    config().put(\"accessNode.api\", `http://localhost:${port}`);\n\n    const { flags = \"\", logging = false } = options;\n    const offset = port - DEFAULT_HTTP_PORT;\n    let grpc = DEFAULT_GRPC_PORT + offset;\n\n    this.logging = logging;\n    this.process = spawn(\"flow\", [\n      \"emulator\",\n      \"--verbose\",\n      `--log-format=JSON`,\n      `--admin-port=${port}`,\n      `--port=${grpc}`,\n      flags,\n    ]);\n    this.logProcessor = (item) => item;\n\n    return new Promise((resolve, reject) => {\n      let internalId;\n      const checkLiveness = async function () {\n        try {\n          await send(build([getBlock(false)])).then(decode);\n          clearInterval(internalId);\n          this.initialized = true;\n          resolve(true);\n        } catch (err) {} // eslint-disable-line no-unused-vars, no-empty\n      };\n      internalId = setInterval(checkLiveness, 100);\n\n      this.process.stdout.on(\"data\", (buffer) => {\n        const data = this.parseDataBuffer(buffer);\n        if (Array.isArray(data)) {\n          let filtered = [];\n          if (this.filters.length > 0) {\n            filtered = data.filter((item) => {\n              const level = this.checkLevel(item.msg, item.level);\n              return this.filters.includes(level);\n            });\n          }\n          for (let i = 0; i < filtered.length; i++) {\n            const item = data[i]\n            const { msg } = item;\n            const level = this.checkLevel(msg, item.level);\n            this.log(`${level.toUpperCase()}: ${msg}`);\n          }\n        } else {\n          const { msg } = data;\n          const level = this.checkLevel(msg, data.level);\n          if (this.filters.length > 0) {\n            if (this.filters.includes(level)) {\n              this.log(`${level.toUpperCase()}: ${msg}`);\n              // TODO: Fix this\n              // This is really hacky solution, which depends on specific phrasing\n              if (msg.includes(\"Starting\") && msg.includes(port)) {\n                this.log(\"EMULATOR IS UP! Listening for events!\");\n              }\n            }\n          } else {\n            this.log(`${level.toUpperCase()}: ${msg}`);\n            if (data.msg.includes(\"Starting HTTP server\")) {\n              this.log(\"EMULATOR IS UP! Listening for events!\");\n            }\n          }\n        }\n      });\n\n      this.process.stderr.on(\"data\", (buffer) => {\n        const { message } = this.parseDataBuffer(buffer);\n        this.log(`EMULATOR ERROR: ${message}`, \"error\");\n        this.initialized = false;\n        clearInterval(internalId);\n        reject();\n      });\n\n      this.process.on(\"close\", (code) => {\n        if (this.filters.includes(\"service\")) {\n          this.log(`EMULATOR: process exited with code ${code}`);\n        }\n        this.initialized = false;\n        clearInterval(internalId);\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * Clear all log filters.\n   * @returns void\n   **/\n  clearFilters() {\n    this.filters = [];\n  }\n\n  /**\n   * Remove specific type of log filter.\n   * @param {(debug|info|warning)} type - type of message\n   * @returns void\n   **/\n  removeFilter(type) {\n    this.filters = this.filters.filter((item) => item !== type);\n  }\n\n  /**\n   * Add log filter.\n   * @param {(debug|info|warning)} type type - type of message\n   * @returns void\n   **/\n  addFilter(type) {\n    if (!this.filters.includes(type)) {\n      this.filters.push(type);\n    }\n  }\n\n  /**\n   * Stop emulator.\n   * @returns Promise<*>\n   */\n  async stop() {\n    // eslint-disable-next-line no-undef\n    return new Promise((resolve) => {\n      this.process.kill();\n      setTimeout(() => {\n        this.initialized = false;\n        resolve(false);\n      }, 50);\n    });\n  }\n}\n\n/** Singleton instance */\nexport default new Emulator();\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getServiceAddress } from \"./manager\";\n\nexport const importManager = async () => {\n  const serviceAddress = await getServiceAddress();\n  return `import FlowManager from ${serviceAddress}`;\n};\n\nexport const importExists = (contractName, code) => {\n  return new RegExp(`import\\\\s+${contractName}`).test(code);\n};\n\nexport const builtInMethods = async (code) => {\n  let injectedImports = code;\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager();\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `;\n  }\n  return injectedImports.replace(/getCurrentBlock\\(\\).height/g, `FlowManager.getBlockHeight()`);\n};\n\nconst addressToIndex = (address) => {\n  return parseInt(address) - 1;\n};\n\nconst addressToAlias = (accounts) => (address) => accounts[addressToIndex(address)];\n\nexport const playgroundImport = (accounts) => async (code) => {\n  let injectedImports = code;\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager();\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `;\n  }\n  return injectedImports.replace(/(?:getAccount\\()(.+)(?:\\))/g, (match, g1) => {\n    const alias = addressToAlias(accounts)(g1);\n    if (!alias) {\n      return `getAccount(FlowManager.resolveDefaultAccounts(${g1}))`;\n    }\n    return `getAccount(FlowManager.getAccountAddress(\"${alias}\"))`;\n  });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { pubFlowKey } from \"./crypto\";\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { getManagerAddress } from \"./manager\";\n\nimport registry from \"./generated\";\n\n/**\n * Returns address of account specified by name. If account with that name doesn't exist it will be created\n * and assigned provided name as alias\n * @param {string} accountName - name of the account\n * @returns {Promise<string|*>}\n */\nexport const getAccountAddress = async (accountName) => {\n  const name = accountName || `deployment-account-${(Math.random() * Math.pow(10, 8)).toFixed(0)}`;\n\n  const managerAddress = await getManagerAddress();\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  };\n\n  let accountAddress;\n\n  const code = await registry.scripts.getAccountAddressTemplate(addressMap);\n\n  const args = [name, managerAddress];\n\n  const [result] = await executeScript({\n    code,\n    args,\n    service: true,\n  });\n  accountAddress = result;\n\n  if (accountAddress === null) {\n    const code = await registry.transactions.createAccountTemplate(addressMap);\n    const publicKey = await pubFlowKey();\n    const args = [name, publicKey, managerAddress];\n\n    const [result] = await sendTransaction({\n      code,\n      args,\n    });\n    const { events } = result;\n    const event = events.find((event) => event.type.includes(\"AccountAdded\"));\n    accountAddress = event.data.address;\n  }\n  return accountAddress;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defaultsByName } from \"./file\";\nimport { replaceImportAddresses } from \"./imports\";\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { makeGetBalance, makeMintTransaction } from \"./templates\";\n\n/**\n * Returns current FlowToken balance of account specified by address\n * @param {string} address - address of account to check\n * @returns {Promise<*>}\n */\nexport const getFlowBalance = async (address) => {\n  const raw = await makeGetBalance(\"FlowToken\");\n  const code = replaceImportAddresses(raw, defaultsByName);\n  const args = [address];\n\n  return executeScript({ code, args });\n};\n\n/**\n * Sends transaction to mint specified amount of FlowToken and send it to recipient.\n * Returns result of the transaction.\n * @param {string} recipient - address of recipient account\n * @param {string} amount - amount to mint and send\n * @returns {Promise<*>}\n */\nexport const mintFlow = async (recipient, amount) => {\n  const raw = await makeMintTransaction(\"FlowToken\");\n  const code = replaceImportAddresses(raw, defaultsByName);\n  const args = [recipient, amount];\n  return sendTransaction({ code, args });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { set } from \"./config\";\nimport { config } from \"@onflow/config\";\n\n/**\n * Inits framework variables, storing private key of service account and base path\n * where Cadence files are stored.\n * @param {string} basePath - path to the folder with Cadence files to be tested.\n * @param {number} [props.port] - port to use for accessAPI\n * @param {number} [props.pkey] - private key to use for service account in case of collisions\n */\nexport const init = async (basePath, props = {}) => {\n  const { port } = props;\n  const { pkey = \"48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902\" } = props;\n\n  set(\"PRIVATE_KEY\", process.env.PK, \"accounts/emulator-account/key\", pkey);\n  set(\n    \"SERVICE_ADDRESS\",\n    process.env.SERVICE_ADDRESS,\n    \"accounts/emulator-account/address\",\n    \"f8d6e0586b0a20c7\",\n  );\n  set(\"BASE_PATH\", process.env.BASE_PATH, \"testing/paths\", basePath);\n\n  // Only set port if it was passed as argument\n  if (port) {\n    config().put(\"accessNode.api\", `http://localhost:${port}`);\n  }\n};\n"],"names":["get","scope","path","fallback","split","length","head","rest","_error","set","key","env","conf","value","flowConfig","config","put","sansPrefix","address","replace","withPrefix","ec","EC","signWithKey","privateKey","msgHex","sig","keyFromPrivate","Buffer","from","sign","sha","SHA3","update","digest","hashMsgHex","r","toArrayLike","s","concat","toString","authorization","addr","keyId","account","serviceAddress","pkey","tempId","fcl","signingFunction","data","signature","message","isObject","arg","_settle","pact","state","_Pact","o","bind","v","then","observer","prototype","onFulfilled","onRejected","result","this","callback","e","_this","body","recover","extractParameters","ixType","params","getServiceAddress","code","ixCode","signers","ixSigners","args","ixArgs","limit","ixLimit","addressMap","defaultsByName","deployedContracts","FlowManager","replaceImportAddresses","target","check","keys","push","array","reject","i","_cycle","thenable","transformer","ixTransformers","ixService","resolveImports","ixName","props","name","transformers","service","Error","getScriptCode","getTransactionCode","sendTransaction","extractor","send","ix","response","tx","onceExecuted","serviceAuth","transaction","payer","proposer","auths","map","authorizations","resolveArguments","resolvedArgs","executeScript","decode","script","CODE","createAccountTemplate","getEnvironment","envMap","fullMap","reportMissingImports","deployContractTemplate","initManagerTemplate","mintTokensTemplate","registerContractTemplate","scratchTemplate","setBlockOffsetTemplate","updateContractTemplate","createAccount","reportMissing","mintTokens","registerContract","scratch","updateContract","txRegistry","hexContract","contract","ixTo","ixAddressMap","ixUpdate","to","deployContract","contractCode","extractContractParameters","containerAddress","managerAddress","hexedCode","deployArgs","schema","generateSchema","item","splitArgs","argLetter","argList","contractName","transactions","getManagerAddress","registry","hexedContract","initManager","getContractAddress","useDefaults","defaultContract","undefined","contractAddress","REGEXP_IMPORT","getPairs","line","filter","collect","acc","extractImports","includes","reduce","byName","match","imp","_","Function","_forTo","FlowToken","FungibleToken","FlowFees","FlowStorageFees","defaultsByAddress","getPath","type","configBase","basePath","typePath","resolve","base","getTemplate","file","byAddress","rawCode","fs","readFileSync","readFile","getContractCode","FlowTokenMap","ExampleToken","lowerFirst","toLowerCase","slice","expect","global","promise","spawn","require","print","log","console","info","error","warn","constructor","initialized","logging","filters","logProcessor","setLogging","checkLevel","level","extractKeyValue","str","fixJSON","msg","splitted","join","parseDataBuffer","JSON","parse","start","port","options","flags","grpc","process","Promise","internalId","setInterval","build","getBlock","clearInterval","_this2","stdout","on","buffer","Array","isArray","filtered","toUpperCase","stderr","clearFilters","removeFilter","addFilter","stop","_this3","kill","setTimeout","injectedImports","RegExp","test","importExists","importManager","imports","resolvedAddress","accountName","Math","random","pow","toFixed","accountAddress","_Buffer","publicKey","getPublic","rlp","encode","pubFlowKey","events","event","find","makeGetBalance","raw","recipient","amount","makeMintTransaction","offset","wrappedInteraction","resolvedStatus","resolvedErrorMessage","status","errorMessage","toBe","not"],"mappings":"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"}